; compression.bb 
; by Chaduke
; 20240606 

; this is my attempt at a compression alogorithm 

; the first step is to take a message and figure out what numeric value components
; appear in the message, then attach a frequency value to each component
; in the case of a byte encoding it could be values of 0-255
; lets do some testing

Dim lookup$(256)
Global msg$
Global total_chars
Dim counts(256)
Dim sort(256)

log_details = False

Global fileout = WriteFile("log.txt")

start_time = MilliSecs()
init_values()
find_total_chars()
WriteLine fileout, Chr$(13) + "Message Length " + Len(msg$)
WriteLine fileout, "Total unique characters counted " + total_chars
; write out the counts table 
WriteLine fileout, Chr$(13) + "Counts Table :"
WriteLine fileout, "Index" + Chr$(9) + "Char" + Chr$(9) + "Count" + Chr$(9) + "Val"
For i = 0 To total_chars-1
	WriteLine fileout, i + Chr$(9) + Chr$(9) + lookup$(i) + Chr$(9) + Chr$(9) + counts(i) + Chr$(9) + Chr$(9) + Asc(lookup$(i))
Next 

sort_by_count()
end_time = MilliSecs()
WriteLine fileout,"Job completed in " + (end_time-start_time) + " milliseconds."
CloseFile fileout 

End 

Function init_values()
	WriteLine fileout, "Initializing lookup and counts table..."
	; clear the lookup table 
	For i=0 To 255
		lookup$(i) = ""
		counts(i) = 0
	Next	
	; init the values	
	msg$ = "Four score and seven years ago our fathers brought forth on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal."
	total_chars = 0
	WriteLine fileout, "The message to be encoded is as follows :"
	WriteLine fileout, msg$
End Function 

Function find_total_chars()
	; loop thru the message
	For i = 1 To Len(msg$)	
		char$= Mid$(msg$,i,1) 
		; now we have to check our lookup table to see if the value exists
		If total_chars > 0 Then 
			; check to see if the character exists
			loop = True
			c = 0
			While loop
				If lookup$(c) = char$ Then 
					; it already exists				
					If log_details Then WriteLine fileout,"Character '" + char$ + "' already exists at index " + c + " incrementing to " + (counts(c) + 1)
					; increment the count table 
					counts(c) = counts(c) + 1
					loop = False
				Else 
					; increment c and check the next character
					c = c + 1
					If c > total_chars Then 
						loop = False
						; it doesn't exist so insert it						
						lookup$(total_chars) = char$
						counts(total_chars) = 1	
						total_chars = total_chars + 1
						If log_details Then WriteLine fileout,"Inserted character at index " + total_chars + " - '" + char$ + "' - " + Asc(char$)
					End If							
				End If	; end lookup		
			Wend ; end while loop					
		Else 
			; insert the first character		
			lookup$(0) = char$
			total_chars = total_chars + 1
			counts(0) = 1
			If log_details Then WriteLine fileout,"Inserted the first character at index 0 - '" + char$ + "'" + "' - " + Asc(char$)
		End If ; end total > 0 		
	Next ; end message loop 
End Function 

Function is_sorted(index,sorted_count) 	
	For j = 0 To sorted_count
	 	If sort(j) = index Then Return True 
	Next 
	Return False
End Function 	

Function sort_by_count()
	; my own sorting algorithm
	; I'm going to just try without doing any research
	; first I need to find the amount thats greatest of all 
	; store that index as the first index of the sort table 
	; then find greatest of the remainding values 
	; in order to do that I have to first check that the value doesn't already exist in the sort table
	; very similar to what I've already done
	
	; find the top count value
	current = 0
	While current < total_chars
		top = 0	
		For i = 0 To total_chars - 1
			c = counts(i)
			If (c > top And is_sorted(i,current)=False) Then 
				top=c
				topi=i
			EndIf	
		Next 
		; now insert the new top value into the sort table 
		sort(current) = topi
		WriteLine fileout, "Index : " + current + " Sort index : " + topi + " Value : " + top
		current - current + 1
	Wend 		
End Function 	







